#!/usr/bin/perl -w
#
# (c)ookie (m)uncher
#
# by: Nick Jennings
#

use strict;

&main();

# load configuration options
sub get_config {
	return (
		log_file => 'access.log',
		chart_char => '*',
	);	
}

# main body of script
sub main {
	my %conf = &get_config();
	my %cookies;   # keys are different cookies
	my @log = &get_log_contents($conf{'log_file'});

	# go through each entry in log and do stuff
	foreach my $entry (@log) {
		next if ($entry =~ /^$/);   # skip blank lines

		my @log_entry = &split_log_entry($entry);   # split log entry into each chunk 
		my ($date, $time) = split(/:/, $log_entry[3], 2);
		my $cookie = $log_entry[$#log_entry];   # cookie is last chunk in log entry

		$cookies{$date}{$cookie}{num}++;   # count cookie instances
	}

	my @dates = keys %cookies;
	#my @dates = &order_dates(keys %cookies);

	foreach my $date (@dates) {
		my @cookie_keys = keys %{ $cookies{$date} };
		#print join("\n", @cookie_keys), "\n";
		foreach my $cookie (@cookie_keys) {
			next unless ($cookies{$date}{$cookie}{num});
			#print "cookie: $cookie, apeared $cookies{$date}{$cookie}{num} times\n";
		}
		#print "total: ", $#cookie_keys + 1, " unique visitors on $date\n\n";
		print "$date: ", $#cookie_keys + 1, " ";
		for (my $c = 0; $c <= $#cookie_keys + 1; $c++) {
			print $conf{chart_char};
		}
		print "\n";
	}

}


# split log entry up and return an array of each chunk of data in line
sub split_log_entry {
	my $line = shift;
	chomp $line;
	my $c = 0;	# counter
	my $dlm = '';	# delimeter
	my $dlm_line = '';	# '|' delimited line

	my @work = split(//, $line);

	# character by character parser to split log data into proper chunks
	foreach my $char (@work) {
		unless ($dlm) {
			$char =~ s/ /|/g;
			if ($char =~ /\[/) {
				$char =~ s/\[/|/;	
				$dlm = ']';
			}
			elsif ($char =~ /"/) {
				$char =~ s/"/|/;
				$dlm = '"';
			}
		}
		else {
			if ($char =~ /$dlm/) {
				$char =~ s/$dlm/|/g;
				$dlm = '';
			}	
		}

		$dlm_line .= $char;
	}

	$dlm_line =~ s/\|+/|/g;
	$dlm_line =~ s/\|$//g;
	$dlm_line =~ s/^\|//g;
	return ( split(/\|/, $dlm_line) );	
}

# open specified log file and return array of the logs data in lines.
sub get_log_contents {
	my $log_file = shift;
	open (LOG, $log_file) or die "Couldn't open $log_file : $!\n";
	my @tmp = <LOG>;
	close LOG;
	return @tmp;
}

# take a group of dates in an expected format (DD/MM/YYYY)
# and return the group ordered from oldest to most recent.
sub order_dates {
	my @dates = @_;
	foreach my $date (@dates) {
		my ($day, $month, $year) = $date;
		unless ($month =~ /^\d{2}$/) {
			$month = &convert_month($month);	
		}
	}
}

# converts the standard 3 letter abreviation for the month into its 
# numerical equivelant
sub convert_month {
        my $month = shift;
        if      ($month =~ /^Jan$/)     { $month = '01'; }      
        elsif   ($month =~ /^Feb$/)     { $month = '02'; }      
        elsif   ($month =~ /^Mar$/)     { $month = '03'; }      
        elsif   ($month =~ /^Apr$/)     { $month = '04'; }      
        elsif   ($month =~ /^May$/)     { $month = '05'; }      
        elsif   ($month =~ /^Jun$/)     { $month = '06'; }      
        elsif   ($month =~ /^Jul$/)     { $month = '07'; }      
        elsif   ($month =~ /^Aug$/)     { $month = '08'; }      
        elsif   ($month =~ /^Sep$/)     { $month = '09'; }      
        elsif   ($month =~ /^Oct$/)     { $month = '10'; }      
        elsif   ($month =~ /^Nov$/)     { $month = '11'; }      
        elsif   ($month =~ /^Dec$/)     { $month = '12'; }      
        return ($month);
}

